import logging
import typing as tp
import time
import asyncio
import uuid
from dataclasses import dataclass
from collections import deque
from enum import Enum

import tinkoff.invest as inv
from tinkoff.invest.async_services import AsyncServices
from connector.info.info_manager import InfoManager, InstrumentInfo
from connector.common.log import Logging
from connector.common.quotation import quotation_to_float, float_to_quotation

if tp.TYPE_CHECKING:
    from connector.runner import Runner
    from connector.strategy import Strategy


####################################################################################################
# Strategy actions
####################################################################################################

class OrderDirection(Enum):
    BUY = 1
    SELL = -1


class OrderType(Enum):
    LIMIT = 0
    MARKET = 1


@dataclass
class NewOrder:
    instrument: InstrumentInfo
    order_type: OrderType
    direction: OrderDirection
    quantity: int  # number of lots
    price: float | None  # per instrument (not per lot), missing for market orders
    idempotency_key: str | None = None  # optional, 36-length, can be generated by uuid.uuid4()


@dataclass
class CancelOrder:
    order_id: str


@dataclass
class ModifyOrder:
    pass


Action = NewOrder | CancelOrder | ModifyOrder


####################################################################################################
# Positions and Open orders
####################################################################################################

@dataclass
class Position:
    balance: int  # available security quantity
    blocked: int  # blocked security quantity for limit orders


@dataclass
class Positions:
    money: float  # available money in rubles
    blocked: float  # blocked money for limit orders
    securities: dict[str, Position]  # security position by figi


class OrderStatus(Enum):
    PENDING = 0  # initial status
    OPEN = 1  # only for limit orders
    PART_FILL = 2  # only for limit orders
    FILL = 3  # final status
    CANCEL = 4  # only for limit orders


@dataclass
class UserOrder:
    # constant fields
    instrument: InstrumentInfo
    order_type: OrderType
    direction: OrderDirection
    initial_quantity: int  # number of lots

    # order ids
    order_id: str | None  # exchange_id
    idempotency_key: str  # key to repeat order request, constant

    # changing fields
    filled_quantity: int  # number of lots
    price: float | None  # per instrument (not per lot), missing for market orders
    status: OrderStatus


@dataclass
class Orders:
    # orders by id
    pending_orders: dict[str, UserOrder]  # pending Orders by idempotency_key
    open_orders: dict[str, UserOrder]  # open User Orders by order_id
    finished_orders: dict[str, UserOrder]  # finished User Orders by order_id


####################################################################################################
# Rate limits manager for one method
####################################################################################################

class RateLimiter:
    SECONDS_IN_MINUTE = 61  # more than 60 for precision errors

    def __init__(self, logger: logging.Logger, method_name: str, limit_per_minute: int):
        self._logger = logger
        self._queue: deque[float] = deque()  # queue with request times
        self._limit_per_minute = limit_per_minute
        self._method_name = method_name

    async def wait_until_available(self) -> None:
        """
        Wait until the request is available
        """
        while True:
            self._remove_irrelevant_requests()
            if len(self._queue) < self._limit_per_minute:
                # queue is not full, just add new request
                self._queue.append(time.time())
                return
            wait_time = self.SECONDS_IN_MINUTE - (time.time() - self._queue[0])
            self._logger.warning(f'Rate limit exceeded for {self._method_name}: wait {wait_time}s')
            await asyncio.sleep(wait_time)

    def _remove_irrelevant_requests(self) -> None:
        """
        Remove requests from queue, that do not affect current request
        """
        now = time.time()
        while self._queue and now - self._queue[0] > self.SECONDS_IN_MINUTE:
            self._queue.popleft()


class UserManager:
    # gRPC rate limits per minute (https://tinkoff.github.io/investAPI/limits/):
    RATE_LIMITS = {
        'get_orders': 200,
        'post_order': 300,
        'cancel_order': 100
    }

    N_ORDER_CONSUMERS = 10  # number of order placers

    def __init__(self):
        self._logger = Logging.get_logger('UserManager')

        # account info
        self._account_id: str | None = None
        self._account: inv.Account | None = None

        # helpers
        self._strategy: tp.Union['Strategy', None] = None
        self._rn: tp.Union['Runner', None] = None
        self._im: InfoManager | None = None
        self._services: AsyncServices | None = None

        # strategy positions and orders
        self._positions: Positions | None = None
        self._orders: Orders = Orders(pending_orders={}, open_orders={}, finished_orders={})

        # rate limiters
        self._rate_limiters: dict[str, RateLimiter] = {
            method_name: RateLimiter(self._logger, method_name, limit) for method_name, limit in self.RATE_LIMITS.items()
        }

        # queue for strategy actions
        self._order_queue: asyncio.Queue[Action] = asyncio.Queue()

    ####################################################################################################
    # Methods for Strategy
    ####################################################################################################

    def new_order(self, order: NewOrder):
        self._logger.info(f'put NewOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    def cancel_order(self, order: CancelOrder):
        self._logger.info(f'put CancelOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    def modify_order(self, order: ModifyOrder):
        self._logger.info(f'put ModifyOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    ####################################################################################################
    # Methods for Runner
    ####################################################################################################

    def set_services(self, services: AsyncServices):
        """
        Only for use in Runner (not in strategy)
        """
        self._services = services

    def set_strategy(self, strategy: 'Strategy') -> None:
        """
        Only for use in Runner (not in strategy)
        """
        self._strategy = strategy

    def set_helpers(self, rn: 'Runner', im: InfoManager) -> None:
        """
        Only for use in Runner (not in strategy)
        """
        self._rn = rn
        self._im = im
        self._account_id = self._rn.get_account_id()

    async def run(self):
        """
        UserManager loop of events
        """
        # get trading account
        await self._get_account()
        # get initial positions
        await self._get_positions()
        # notify Runner that UserManager is ready
        self._rn.on_user_manager_ready()

        # order consumers loop
        consumers = [asyncio.create_task(self._order_consumer()) for _ in range(self.N_ORDER_CONSUMERS)]
        await asyncio.gather(*consumers)

    ####################################################################################################
    # Private Methods for initial Positions retrieval
    ####################################################################################################

    async def _get_positions(self) -> None:
        positions = await self._services.operations.get_positions(account_id=self._account_id)
        self._logger.info(f'tinkoff positions={positions}')

        # check money positions
        money: float | None = None
        for quotation in positions.money:
            assert quotation.currency == 'rub', 'Only ruble money value is supported'
            assert money is None, 'Multiple money values are found'
            money = quotation_to_float(quotation)
        assert len(positions.blocked) == 0, 'Remove all old buy orders before starting strategy'

        # check segments positions
        assert len(positions.futures) == 0 and len(positions.options) == 0, 'Close all futures and options positions'

        # check security positions
        security_positions_by_figi: dict[str, Position] = {}
        for security in positions.securities:
            assert self._im.has_instrument_by_figi(security.figi), 'Unknown security position found'
            assert security.blocked == 0, 'Remove all old sell orders before starting strategy'
            assert not security.exchange_blocked, 'Instrument is blocked on exchange'
            assert security.balance > 0, 'Sanity check'
            assert security.instrument_type == self._im.get_instrument_by_figi(security.figi).instrument_type, f'Sanity check'
            security_positions_by_figi[security.figi] = Position(balance=security.balance, blocked=security.blocked)

        # fill positions
        self._positions = Positions(money=money, blocked=0.0, securities=security_positions_by_figi)
        self._logger.info(f'parsed positions={self._positions}')

    async def _get_account(self) -> None:
        """
        Find an account to trade on
        Fill self._account field
        """
        accounts = (await self._services.users.get_accounts()).accounts
        # log all accounts
        self._logger.info(f'number of accounts: {len(accounts)}')
        for account in accounts:
            self._logger.info(f'found account: {account}')
        assert self._account_id is not None, 'Account was not specified'
        # get trading account
        try:
            trading_account = next(filter(lambda acc: acc.id == self._account_id, accounts))
        except StopIteration:
            self._logger.error(f'account with id={self._account_id} was not found')
            raise
        # accessibility checks
        assert trading_account.status == inv.AccountStatus.ACCOUNT_STATUS_OPEN, f'Account {trading_account} must be opened'
        assert trading_account.access_level == inv.AccessLevel.ACCOUNT_ACCESS_LEVEL_FULL_ACCESS, f'Must have full access to {trading_account}'
        # fill field
        self._account = trading_account

        # log user rate limits
        limits = await self._services.users.get_user_tariff()
        self._logger.info(f'User Limits: {limits}')

        # log user tariff
        tariff = await self._services.users.get_info()
        self._logger.info(f'tariff="{tariff.tariff}"; is_premium={tariff.prem_status}; is_qual={tariff.qual_status}; qualified_for_work_with={tariff.qualified_for_work_with}')

    ####################################################################################################
    # Private Method for handling rate limits
    ####################################################################################################

    async def _wait_until_available(self, method: str) -> None:
        """
        Wait until the request is available
        """
        await self._rate_limiters[method].wait_until_available()

    ####################################################################################################
    # Private Methods for processing strategy actions
    ####################################################################################################

    async def _order_consumer(self):
        """
        Consume and process orders from the order_queue
        """
        while True:
            order = await self._order_queue.get()
            self._logger.info(f'process from queue: {order}')
            await self._process_action(order)

    async def _process_action(self, order: Action) -> None:
        """
        Process strategy order
        """
        if isinstance(order, NewOrder):
            await self._process_new_order(order)
        elif isinstance(order, CancelOrder):
            await self._process_cancel_order(order)
        elif isinstance(order, ModifyOrder):
            await self._process_modify_order(order)
        else:
            assert False, 'Unreachable'

    async def _process_new_order(self, order: NewOrder) -> None:
        """
        NewOrder
        """
        # construct order
        assert order.order_type == OrderType.MARKET or order.price is not None, 'Limit order must have price'
        idempotency_key = str(uuid.uuid4())
        user_order = UserOrder(
            instrument=order.instrument,
            order_type=order.order_type,
            direction=order.direction,
            initial_quantity=order.quantity,
            order_id=None,
            idempotency_key=idempotency_key,
            filled_quantity=0,
            price=order.price,
            status=OrderStatus.PENDING
        )
        self._orders.pending_orders[idempotency_key] = user_order

        # send order
        price_quotation = float_to_quotation(order.price) if order.order_type == OrderType.LIMIT else None
        await self._wait_until_available('post_order')
        response = await self._services.orders.post_order(
            figi=order.instrument.figi,
            quantity=order.quantity,
            price=price_quotation,
            direction=inv.OrderDirection.ORDER_DIRECTION_BUY if order.direction == OrderDirection.BUY else inv.OrderDirection.ORDER_DIRECTION_SELL,
            account_id=self._account_id,
            order_type=inv.OrderType.ORDER_TYPE_LIMIT if order.order_type == OrderType.LIMIT else inv.OrderType.ORDER_TYPE_MARKET,
            order_id=idempotency_key  # inconsistent tinkoff naming, actually it is idempotency_key
        )

        # check response for errors
        self._logger.info(f'Got PostOrder response: {response}')
        # assert order_id == response.order_id, 'Sanity check'
        assert order.instrument.figi == response.figi, 'Sanity check'
        if response.execution_report_status not in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW,
                                                    inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL,
                                                    inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL]:
            raise RuntimeError(f'Wrong response status: {response.execution_report_status}; message: {response.message}')
        assert order.quantity == response.lots_requested, 'Sanity check'

        assert order.order_type == OrderType.LIMIT or order.quantity == response.lots_executed, 'Market order should be always executed'
        assert (order.order_type == OrderType.MARKET or
                response.execution_report_status not in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL,
                                                         inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL] or
                price_quotation == response.executed_order_price), 'Limit order fill price should be the same as we requested'
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            assert response.lots_executed == order.quantity, 'Sanity check'
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL:
            assert response.lots_executed < order.quantity, 'Sanity check'
        # TODO: remove commission check due to change in commissions
        assert quotation_to_float(response.initial_commission) == 0 and quotation_to_float(response.executed_commission) == 0, 'Commission check'

        # remove order from pending_orders
        self._orders.pending_orders.pop(idempotency_key)
        # add order to open_orders or finished_orders
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            self._orders.finished_orders[response.order_id] = user_order
        else:
            self._orders.open_orders[response.order_id] = user_order

        # update pending_order_id (idempotency_key) -> order_id
        user_order.order_id = response.order_id
        # update status
        user_order.status = self._tinkoff_order_status_to_local(response.execution_report_status)
        # update filled quantity
        user_order.filled_quantity = response.lots_executed
        # notify strategy
        self._strategy.on_order_event(user_order)

    async def _process_cancel_order(self, order: CancelOrder) -> None:
        """
        CancelOrder
        """
        pass  # TODO:

    async def _process_modify_order(self, order: ModifyOrder) -> None:
        """
        ModifyOrder
        """
        pass  # TODO:

    @staticmethod
    def _tinkoff_order_status_to_local(status: inv.OrderExecutionReportStatus):
        match status:
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW:
                return OrderStatus.OPEN
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
                return OrderStatus.FILL
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL:
                return OrderStatus.PART_FILL
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_CANCELLED:
                return OrderStatus.CANCEL
            case _:
                assert False, 'Unreachable'
