import logging
import typing as tp
import time
import asyncio
import uuid
from dataclasses import dataclass
from collections import deque
from enum import Enum

import tinkoff.invest as inv
from grpc import StatusCode
from tinkoff.invest.async_services import AsyncServices
from connector.info.info_manager import InfoManager, InstrumentInfo
from connector.common.log import Logging
from connector.common.quotation import quotation_to_float, float_to_quotation

if tp.TYPE_CHECKING:
    from connector.runner import Runner
    from connector.strategy import Strategy


####################################################################################################
# Strategy actions
####################################################################################################

class OrderDirection(Enum):
    BUY = 1
    SELL = -1


class OrderType(Enum):
    LIMIT = 0
    MARKET = 1


@dataclass
class NewOrder:
    instrument: InstrumentInfo
    order_type: OrderType
    direction: OrderDirection
    quantity: int  # number of lots
    price: float | None  # per instrument (not per lot), missing for market orders
    idempotency_key: str | None = None  # optional, 36-length, can be generated by uuid.uuid4()


@dataclass
class CancelOrder:
    order_id: str


@dataclass
class ModifyOrder:
    order_id: str
    new_quantity: int  # number of lots
    new_price: float  # per instrument (not per lot)


Action = NewOrder | CancelOrder | ModifyOrder


####################################################################################################
# Positions
####################################################################################################

@dataclass
class Position:
    """
    Container to manage positions (our balance in securities)
    """
    instrument: InstrumentInfo
    balance: int  # available security quantity in lots
    blocked: int  # blocked security quantity for limit orders in lots


@dataclass
class Positions:
    money: float  # available money in rubles
    blocked: float  # blocked money for limit orders
    securities: dict[str, Position]  # security position by figi

    ####################################################################################################
    # Methods for Strategy
    ####################################################################################################

    def description(self) -> str:
        """
        Small string representation of positions
        """
        security_strings = []
        for i, (figi, position) in enumerate(self.securities.items(), start=1):
            security_strings.append(f'\n{i}. {figi}: [balance={position.balance}, blocked={position.blocked}]')
        security_string = ''.join(security_strings)
        return (f'\n'
                f'money={self.money}\n'
                f'blocked={self.blocked}\n'
                f'n_securities: {len(self.securities)}'
                f'{security_string}')

    ####################################################################################################
    # Methods for UserManager
    ####################################################################################################

    def process_post_order_response(self, request: NewOrder, response: inv.PostOrderResponse) -> None:
        """
        Process response after placing order
        """

        ####################################################################################################
        # Security
        ####################################################################################################

        security_position = self.securities[request.instrument.figi]
        sign = self._direction_sign(request.direction)
        # balance
        security_position.balance += sign * response.lots_executed
        # blocked
        if request.order_type == OrderType.LIMIT and request.direction == OrderDirection.SELL:
            security_position.blocked += (response.lots_requested - response.lots_executed)

        ####################################################################################################
        # Money
        ####################################################################################################

        # balance
        self.money -= sign * response.lots_executed * request.instrument.lot * quotation_to_float(response.executed_order_price)
        # blocked
        if request.order_type == OrderType.LIMIT and request.direction == OrderDirection.BUY:
            self.blocked += (response.lots_requested - response.lots_executed) * request.instrument.lot * request.price

    def process_cancel_order_response(self, user_order: 'UserOrder') -> None:
        """
        Process response after canceling order
        """
        assert user_order.last_state.status == OrderStatus.CANCEL, 'Sanity check'  # Order is updated before positions

        ####################################################################################################
        # Security
        ####################################################################################################

        security_position = self.securities[user_order.instrument.figi]
        # blocked
        if user_order.order_type == OrderType.LIMIT and user_order.direction == OrderDirection.SELL:
            security_position.blocked -= (user_order.initial_quantity - user_order.filled_quantity)

        ####################################################################################################
        # Money
        ####################################################################################################

        # blocked
        if user_order.order_type == OrderType.LIMIT and user_order.direction == OrderDirection.BUY:
            self.blocked += (user_order.initial_quantity - user_order.filled_quantity) * user_order.instrument.lot * user_order.price

    def process_modify_order_response(self, request: ModifyOrder, response: inv.PostOrderResponse, user_order: 'UserOrder') -> None:
        """
        Process response after modifying order
        """
        # cancel old order
        self.process_cancel_order_response(
            UserOrder(
                instrument=user_order.instrument,
                order_type=user_order.order_type,
                direction=user_order.direction,
                initial_quantity=user_order.initial_quantity,
                price=user_order.price,
                order_id=user_order.order_id,
                idempotency_key=user_order.idempotency_key,
                states=[user_order.states[-2]]  # use state before modifying order
            )
        )
        # place new order
        self.process_post_order_response(NewOrder(
            instrument=user_order.instrument,
            order_type=user_order.order_type,
            direction=user_order.direction,
            quantity=request.new_quantity,
            price=request.new_price,
            idempotency_key=""  # is not used
        ), response)

    def process_get_order(self, user_order: 'UserOrder') -> None:
        """
        Process GetOrders/GetOrderState response
        """

        old_filled_quantity = user_order.states[-2].filled_quantity
        new_filled_quantity = user_order.states[-1].filled_quantity
        additional_filled_quantity = new_filled_quantity - old_filled_quantity
        if additional_filled_quantity == 0:
            return

        ####################################################################################################
        # Security
        ####################################################################################################

        security_position = self.securities[user_order.instrument.figi]
        sign = self._direction_sign(user_order.direction)
        # balance
        security_position.balance += sign * additional_filled_quantity
        # blocked
        if user_order.order_type == OrderType.LIMIT and user_order.direction == OrderDirection.SELL:
            security_position.blocked -= additional_filled_quantity

        ####################################################################################################
        # Money
        ####################################################################################################

        # balance
        self.money -= sign * additional_filled_quantity * user_order.instrument.lot * user_order.price
        # blocked
        if user_order.order_type == OrderType.LIMIT and user_order.direction == OrderDirection.BUY:
            self.blocked -= additional_filled_quantity * user_order.instrument.lot * user_order.price

    ####################################################################################################
    # Private Methods
    ####################################################################################################

    @staticmethod
    def _direction_sign(direction: OrderDirection) -> int:
        """
        Buy  -> +1
        Sell -> -1
        """
        match direction:
            case OrderDirection.BUY:
                return +1
            case OrderDirection.SELL:
                return -1
            case _:
                assert False, 'Unreachable'


####################################################################################################
# Pending, Open and Finished orders
####################################################################################################

class OrderStatus(Enum):
    PENDING_OPEN = 0  # initial status
    PENDING_CANCEL = 1
    PENDING_MODIFY = 2
    OPEN = 3
    PART_FILL = 4
    FILL = 5  # final status
    CANCEL = 6  # final status

    def is_closed(self):
        return self == OrderStatus.FILL or self == OrderStatus.CANCEL


# changing fields of UserOrder
@dataclass
class UserOrderState:
    filled_quantity: int  # number of lots
    status: OrderStatus


@dataclass
class UserOrder:
    # constant fields
    instrument: InstrumentInfo
    order_type: OrderType
    direction: OrderDirection
    initial_quantity: int  # number of lots
    price: float | None  # per instrument (not per lot), missing for market orders

    # order ids
    order_id: str | None  # exchange_id
    idempotency_key: str  # key to repeat order request, constant

    # changing field
    states: list[UserOrderState]  # list of order updates

    @property
    def filled_quantity(self) -> int:
        """
        Latest version of filled quantity
        """
        return self.states[-1].filled_quantity

    @property
    def status(self) -> OrderStatus:
        """
        Latest version of status
        """
        return self.states[-1].status

    @property
    def last_state(self) -> UserOrderState:
        """
        Latest version of state
        """
        return self.states[-1]

    def update_state(self, filled_quantity: int | None = None, status: OrderStatus | None = None) -> None:
        """
        Update UserOrder state (only for use in UserManager)
        """
        filled_quantity = filled_quantity or self.filled_quantity
        status = status or self.status
        self.states.append(
            UserOrderState(filled_quantity=filled_quantity, status=status)
        )


@dataclass
class Orders:
    """
    Container to manage orders (our limit and market orders)
    """
    pending_orders: dict[str, UserOrder]  # pending Orders by idempotency_key
    open_orders: dict[str, UserOrder]  # open User Orders by order_id
    finished_orders: dict[str, UserOrder]  # finished User Orders by order_id

    ####################################################################################################
    # Methods for Strategy
    ####################################################################################################

    def description(self) -> str:
        """
        Small string representation of orders
        """
        return (f'{self._orders_description("pending_orders", self.pending_orders)}; '
                f'{self._orders_description("open_orders", self.open_orders)}; '
                f'{self._orders_description("finished_orders", self.finished_orders)}')

    ####################################################################################################
    # Methods for UserManager
    ####################################################################################################

    def create_pending_open_order(self, idempotency_key: str, request: NewOrder) -> None:
        """
        Before NewOrder request
        """
        assert idempotency_key not in self.pending_orders, 'Sanity check'
        assert request.order_type == OrderType.MARKET or request.price is not None, 'Limit order must have price'
        user_order = UserOrder(
            instrument=request.instrument,
            order_type=request.order_type,
            direction=request.direction,
            initial_quantity=request.quantity,
            price=request.price,
            order_id=None,
            idempotency_key=idempotency_key,
            states=[UserOrderState(filled_quantity=0, status=OrderStatus.PENDING_OPEN)]
        )
        self.pending_orders[idempotency_key] = user_order  # add pending order

    def process_post_order_response(self, idempotency_key: str, response: inv.PostOrderResponse) -> UserOrder:
        """
        After NewOrder request
        After ModifyOrder request
        """
        user_order = self.pending_orders.pop(idempotency_key)  # remove order from pending_orders
        # add order to open_orders or finished_orders
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            self.finished_orders[response.order_id] = user_order  # order is finished immediately
        else:
            self.open_orders[response.order_id] = user_order  # limit order is placed
        user_order.order_id = response.order_id  # (!) set order_id
        # update state
        user_order.update_state(
            filled_quantity=response.lots_executed,
            status=self._tinkoff_order_status_to_local(response.execution_report_status)
        )
        return user_order

    def create_pending_cancel_order(self, request: CancelOrder) -> None:
        """
        Before CancelOrder request
        """
        assert request.order_id in self.open_orders, 'Sanity check'
        # open order -> pending order
        user_order = self.open_orders.pop(request.order_id)
        self.pending_orders[request.order_id] = user_order
        # update state
        user_order.update_state(
            status=OrderStatus.PENDING_CANCEL
        )

    def process_cancel_order_response(self, request: CancelOrder) -> UserOrder:
        """
        After CancelOrder request
        """
        user_order = self.pending_orders.pop(request.order_id)  # remove order from pending_orders
        self.finished_orders[request.order_id] = user_order  # add order to finished_orders
        user_order.update_state(status=OrderStatus.CANCEL)
        return user_order

    def create_pending_modify_order(self, idempotency_key: str, request: ModifyOrder) -> None:
        """
        Before ModifyOrder request
        """
        assert idempotency_key not in self.pending_orders, 'Sanity check'
        assert request.order_id in self.open_orders, 'Sanity check'
        # open order -> pending order
        user_order = self.open_orders.pop(request.order_id)
        user_order.update_state(status=OrderStatus.PENDING_MODIFY)
        self.pending_orders[request.order_id] = user_order

    def process_get_order(self, order: inv.OrderState, logger: logging.Logger) -> tuple[UserOrder, bool]:
        """
        Return whether to notify strategy or not
        """
        notify = False
        user_order = self.open_orders[order.order_id] if order.order_id in self.open_orders else self.pending_orders[order.order_id]
        new_status = self._tinkoff_order_status_to_local(order.execution_report_status)
        if user_order.status != new_status:
            logger.warning(f'Order {order.order_id} changed status: {user_order.status} -> {new_status}')
        if user_order.filled_quantity < order.lots_executed:
            logger.info(f'Order {order.order_id} changed filled quantity: {user_order.filled_quantity}/{user_order.initial_quantity} -> {order.lots_executed}/{order.lots_requested}')
            notify = True  # notify about PARTIAL_FILL/FILL
        user_order.update_state(
            filled_quantity=order.lots_executed,
            status=new_status
        )
        if user_order.status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            assert user_order.filled_quantity == user_order.initial_quantity, 'Sanity check'
            logger.info(f'Order {order.order_id} is filled: {user_order.filled_quantity}/{user_order.initial_quantity}')
            # open order -> finished order
            if order.order_id in self.open_orders:
                self.open_orders.pop(order.order_id)
            else:
                self.pending_orders.pop(order.order_id)
            self.finished_orders[order.order_id] = user_order
        return user_order, notify

    ####################################################################################################
    # Private Methods
    ####################################################################################################

    @staticmethod
    def _orders_description(orders_name: str, orders_dict: dict[str, UserOrder]) -> str:
        order_strings = []
        for i, (order_id, user_order) in enumerate(orders_dict.items(), start=1):
            order_strings.append(f'\n{i}. {order_id}: '
                                 f'[{user_order.instrument.ticker}, '
                                 f'{user_order.order_type}, '
                                 f'{user_order.direction}, '
                                 f'{user_order.price}, '
                                 f'{user_order.filled_quantity}/{user_order.initial_quantity}, '
                                 f'{user_order.status}]')
        order_string = ''.join(order_strings)
        return (f'{orders_name}: {len(orders_dict)}'
                f'{order_string}')

    @staticmethod
    def _tinkoff_order_status_to_local(status: inv.OrderExecutionReportStatus):
        match status:
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW:
                return OrderStatus.OPEN
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
                return OrderStatus.FILL
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL:
                return OrderStatus.PART_FILL
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_CANCELLED:
                return OrderStatus.CANCEL
            case _:
                assert False, 'Unreachable'


####################################################################################################
# Rate limits manager for one method
####################################################################################################

class RateLimiter:
    SECONDS_IN_MINUTE = 61  # more than 60 for precision errors

    def __init__(self, logger: logging.Logger, method_name: str, limit_per_minute: int):
        self._logger = logger
        self._queue: deque[float] = deque()  # queue with request times
        self._limit_per_minute = limit_per_minute
        self._method_name = method_name

    async def wait_until_available(self) -> None:
        """
        Wait until the request is available
        """
        while True:
            self._remove_irrelevant_requests()
            if len(self._queue) < self._limit_per_minute:
                # queue is not full, just add new request
                self._queue.append(time.time())
                return
            wait_time = self.SECONDS_IN_MINUTE - (time.time() - self._queue[0])
            self._logger.warning(f'Rate limit exceeded for {self._method_name}: wait {wait_time}s')
            await asyncio.sleep(wait_time)

    def get_optimal_time_between_requests(self) -> float:
        """
        Returns optimal time to wait between two requests in seconds
        """
        self._remove_irrelevant_requests()
        if not self._queue:
            return self.SECONDS_IN_MINUTE / self._limit_per_minute
        remaining_time = self.SECONDS_IN_MINUTE - (time.time() - self._queue[0])
        remaining_requests = self._limit_per_minute - len(self._queue)
        optimal_wait_time = remaining_time / remaining_requests if remaining_requests != 0 else remaining_time
        self._logger.debug(f'{self._method_name}: {remaining_time=}, {remaining_requests=}, {optimal_wait_time=}')
        return optimal_wait_time

    def _remove_irrelevant_requests(self) -> None:
        """
        Remove requests from queue, that do not affect current request
        """
        now = time.time()
        while self._queue and now - self._queue[0] > self.SECONDS_IN_MINUTE:
            self._queue.popleft()


class UserManager:
    # gRPC rate limits per minute (https://tinkoff.github.io/investAPI/limits/):
    RATE_LIMITS = {
        'get_orders': 200,
        'post_order': 300,
        'cancel_order': 100
    }

    N_ACTION_CONSUMERS = 10  # number of order placers

    def __init__(self):
        self._logger = Logging.get_logger('UserManager')

        # account info
        self._account_id: str | None = None
        self._account: inv.Account | None = None

        # helpers
        self._strategy: tp.Union['Strategy', None] = None
        self._rn: tp.Union['Runner', None] = None
        self._im: InfoManager | None = None
        self._services: AsyncServices | None = None

        # strategy positions and orders
        self._positions: Positions | None = None
        self._orders: Orders = Orders(pending_orders={}, open_orders={}, finished_orders={})

        # rate limiters
        self._rate_limiters: dict[str, RateLimiter] = {
            method_name: RateLimiter(self._logger, method_name, limit) for method_name, limit in self.RATE_LIMITS.items()
        }

        # queue for strategy actions
        self._order_queue: asyncio.Queue[Action] = asyncio.Queue()

    ####################################################################################################
    # Methods for Strategy
    ####################################################################################################

    def get_orders(self) -> Orders:
        """
        Return the view of Orders structure
        """
        return self._orders

    def get_positions(self) -> Positions:
        """
        Return the view of Positions structure
        """
        assert self._positions is not None, 'Sanity check'
        return self._positions

    def new_order(self, order: NewOrder):
        self._logger.info(f'put NewOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    def cancel_order(self, order: CancelOrder):
        self._logger.info(f'put CancelOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    def modify_order(self, order: ModifyOrder):
        self._logger.info(f'put ModifyOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    ####################################################################################################
    # Methods for Runner
    ####################################################################################################

    def set_services(self, services: AsyncServices):
        """
        Only for use in Runner (not in strategy)
        """
        self._services = services

    def set_strategy(self, strategy: 'Strategy') -> None:
        """
        Only for use in Runner (not in strategy)
        """
        self._strategy = strategy

    def set_helpers(self, rn: 'Runner', im: InfoManager) -> None:
        """
        Only for use in Runner (not in strategy)
        """
        self._rn = rn
        self._im = im
        self._account_id = self._rn.get_account_id()

    async def run(self):
        """
        UserManager loop of events
        """
        # get trading account
        await self._get_account()
        # get initial positions
        await self._get_positions()
        # notify Runner that UserManager is ready
        self._rn.on_user_manager_ready()

        # action consumers loop
        consumers = [asyncio.create_task(self._action_consumer()) for _ in range(self.N_ACTION_CONSUMERS)]
        await asyncio.gather(*consumers, self._monitor_orders())

    ####################################################################################################
    # Private Methods for initial Positions retrieval
    ####################################################################################################

    async def _get_positions(self) -> None:
        positions = await self._services.operations.get_positions(account_id=self._account_id)
        self._logger.info(f'tinkoff positions={positions}')

        # check money positions
        money: float | None = None
        for quotation in positions.money:
            assert quotation.currency == 'rub', 'Only ruble money value is supported'
            assert money is None, 'Multiple money values are found'
            money = quotation_to_float(quotation)
        assert len(positions.blocked) == 0, 'Remove all old buy orders before starting strategy'

        # check segments positions
        assert len(positions.futures) == 0 and len(positions.options) == 0, 'Close all futures and options positions'

        # check security positions
        security_positions_by_figi: dict[str, Position] = {}
        for security in positions.securities:
            assert self._im.has_instrument_by_figi(security.figi), 'Unknown security position found'
            assert security.blocked == 0, 'Remove all old sell orders before starting strategy'
            assert not security.exchange_blocked, 'Instrument is blocked on exchange'
            assert security.balance > 0, 'Sanity check'
            instrument_info = self._im.get_instrument_by_figi(security.figi)
            assert security.instrument_type == instrument_info.instrument_type, 'Sanity check'
            assert security.balance % instrument_info.lot == 0, f'Sanity check'
            assert security.blocked % instrument_info.lot == 0, 'Sanity check'
            security_positions_by_figi[security.figi] = Position(
                instrument=instrument_info,
                balance=security.balance // instrument_info.lot,
                blocked=security.blocked // instrument_info.lot
            )

        # fill positions
        self._positions = Positions(money=money, blocked=0.0, securities=security_positions_by_figi)
        self._logger.info(f'parsed positions={self._positions}')

    async def _get_account(self) -> None:
        """
        Find an account to trade on
        Fill self._account field
        """
        accounts = (await self._services.users.get_accounts()).accounts
        # log all accounts
        self._logger.info(f'number of accounts: {len(accounts)}')
        for account in accounts:
            self._logger.info(f'found account: {account}')
        assert self._account_id is not None, 'Account was not specified'
        # get trading account
        try:
            trading_account = next(filter(lambda acc: acc.id == self._account_id, accounts))
        except StopIteration:
            self._logger.error(f'account with id={self._account_id} was not found')
            raise
        # accessibility checks
        assert trading_account.status == inv.AccountStatus.ACCOUNT_STATUS_OPEN, f'Account {trading_account} must be opened'
        assert trading_account.access_level == inv.AccessLevel.ACCOUNT_ACCESS_LEVEL_FULL_ACCESS, f'Must have full access to {trading_account}'
        # fill field
        self._account = trading_account

        # log user rate limits
        limits = await self._services.users.get_user_tariff()
        self._logger.info(f'User Limits: {limits}')

        # log user tariff
        tariff = await self._services.users.get_info()
        self._logger.info(f'tariff="{tariff.tariff}"; is_premium={tariff.prem_status}; is_qual={tariff.qual_status}; qualified_for_work_with={tariff.qualified_for_work_with}')

    ####################################################################################################
    # Private Method for monitoring open orders
    ####################################################################################################

    async def _monitor_orders(self):
        rate_limiter = self._rate_limiters['get_orders']
        while True:
            wait_time = rate_limiter.get_optimal_time_between_requests()
            await asyncio.sleep(wait_time)
            await rate_limiter.wait_until_available()
            response = await self._services.orders.get_orders(account_id=self._account_id)
            self._logger.debug(f'Got GetOrders response: {len(response.orders)} orders: {response}')
            for order in response.orders:
                self._process_get_order(order)
            order_ids = {order.order_id for order in response.orders}
            for order_id, user_order in list(self._orders.open_orders.items()) + list(self._orders.pending_orders.items()):
                if order_id not in order_ids and user_order.status != OrderStatus.PENDING_OPEN:
                    await rate_limiter.wait_until_available()
                    self._logger.debug(f'Look for {user_order}')
                    response = await self._services.orders.get_order_state(account_id=self._account_id, order_id=order_id)
                    assert response.order_id == order_id, 'Sanity check'
                    self._process_get_order(response)

    ####################################################################################################
    # Private Method for handling rate limits
    ####################################################################################################

    async def _wait_until_available(self, method: str) -> None:
        """
        Wait until the request is available
        """
        await self._rate_limiters[method].wait_until_available()

    ####################################################################################################
    # Private Methods for processing strategy actions
    ####################################################################################################

    async def _action_consumer(self):
        """
        Consume and process orders from the order_queue
        """
        while True:
            action = await self._order_queue.get()
            self._logger.info(f'process from queue: {action}')
            await self._process_action(action)

    async def _process_action(self, action: Action) -> None:
        """
        Process strategy order (New, Cancel, Modify)
        """
        if isinstance(action, NewOrder):
            await self._process_new_order(action)
        elif isinstance(action, CancelOrder):
            await self._process_cancel_order(action)
        elif isinstance(action, ModifyOrder):
            await self._process_modify_order(action)
        else:
            assert False, 'Unreachable'

    async def _process_new_order(self, request: NewOrder) -> None:
        """
        Construct pending open order
        Send order and receive response
        Check response for errors
        Update Orders structure
        Update Positions structure
        Notify Strategy
        """

        ####################################################################################################
        # Construct pending open order
        ####################################################################################################

        # From requests with the same idempotency_key only the first one will be executed
        # idempotency_key is needed to repeat request in case we do not get the correct response from server
        idempotency_key = str(uuid.uuid4())
        request.idempotency_key = idempotency_key
        self._orders.create_pending_open_order(idempotency_key, request)
        # TODO: think about positions updates

        ####################################################################################################
        # Send order and receive response
        ####################################################################################################

        await self._wait_until_available('post_order')
        response = await self._services.orders.post_order(
            figi=request.instrument.figi,
            quantity=request.quantity,
            price=float_to_quotation(request.price) if request.order_type == OrderType.LIMIT else None,
            direction=inv.OrderDirection.ORDER_DIRECTION_BUY if request.direction == OrderDirection.BUY else inv.OrderDirection.ORDER_DIRECTION_SELL,
            account_id=self._account_id,
            order_type=inv.OrderType.ORDER_TYPE_LIMIT if request.order_type == OrderType.LIMIT else inv.OrderType.ORDER_TYPE_MARKET,
            order_id=idempotency_key  # inconsistent tinkoff naming, actually it is idempotency_key
        )
        self._logger.info(f'Got PostOrder response: {response}')

        ####################################################################################################
        # Check response for errors
        ####################################################################################################

        self._check_new_order_errors(request, response)

        ####################################################################################################
        # Update Orders structure
        ####################################################################################################

        user_order = self._orders.process_post_order_response(idempotency_key, response)

        ####################################################################################################
        # Update Positions structure
        ####################################################################################################

        self._positions.process_post_order_response(request, response)

        ####################################################################################################
        # Notify Strategy
        ####################################################################################################

        self._strategy.on_order_event(user_order)

    async def _process_cancel_order(self, request: CancelOrder) -> None:
        """
        Construct pending cancel order
        Send cancel order and receive response
        Update Orders structure
        Notify Strategy
        """

        ####################################################################################################
        # Construct pending cancel order
        ####################################################################################################

        self._orders.create_pending_cancel_order(request)
        # TODO: think about positions updates?

        ####################################################################################################
        # Send cancel order and receive response
        ####################################################################################################

        await self._wait_until_available('cancel_order')
        if request.order_id not in self._orders.pending_orders:
            self._logger.error(f'Order {request.order_id} was finished before cancel')
            return
        try:
            response = await self._services.orders.cancel_order(account_id=self._account_id, order_id=request.order_id)
        except inv.exceptions.AioRequestError as ex:
            self._logger.exception('Exception in CancelOrder')
            assert ex.code == StatusCode.INVALID_ARGUMENT
            return
        # log response
        self._logger.info(f'Got CancelOrder response: {response}')

        ####################################################################################################
        # Update Orders structure
        ####################################################################################################

        user_order = self._orders.process_cancel_order_response(request)

        ####################################################################################################
        # Update Positions structure
        ####################################################################################################

        self._positions.process_cancel_order_response(user_order)

        ####################################################################################################
        # Notify Strategy
        ####################################################################################################

        self._strategy.on_order_event(user_order)

    async def _process_modify_order(self, request: ModifyOrder) -> None:
        """
        ModifyOrder
        """

        ####################################################################################################
        # Construct pending modify order
        ####################################################################################################

        idempotency_key = str(uuid.uuid4())
        self._orders.create_pending_modify_order(idempotency_key, request)
        # TODO: think about positions updates?

        ####################################################################################################
        # Send cancel order and receive response
        ####################################################################################################

        # TODO: check rate limits
        await self._wait_until_available('cancel_order')
        await self._wait_until_available('post_order')
        tinkoff_request = inv.ReplaceOrderRequest()  # construct request due to python-sdk library problems
        tinkoff_request.account_id = self._account_id
        tinkoff_request.order_id = request.order_id
        tinkoff_request.idempotency_key = idempotency_key
        tinkoff_request.quantity = request.new_quantity
        tinkoff_request.price = float_to_quotation(request.new_price)
        tinkoff_request.price_type = inv.PriceType.PRICE_TYPE_UNSPECIFIED
        response = await self._services.orders.replace_order(tinkoff_request)

        ####################################################################################################
        # Update Orders structure
        ####################################################################################################

        user_order = self._orders.process_post_order_response(idempotency_key, response)

        ####################################################################################################
        # Update Positions structure
        ####################################################################################################

        self._positions.process_modify_order_response(request, response, user_order)

        ####################################################################################################
        # Notify Strategy
        ####################################################################################################

        self._strategy.on_order_event(user_order)

    def _process_get_order(self, order: inv.OrderState) -> None:
        if not self._check_get_order_errors(order):
            return  # order_id was not found in open_orders

        ####################################################################################################
        # Update Orders structure
        ####################################################################################################

        user_order, notify = self._orders.process_get_order(order, self._logger)

        ####################################################################################################
        # Update Positions structure
        ####################################################################################################

        self._positions.process_get_order(user_order)

        ####################################################################################################
        # Notify Strategy
        ####################################################################################################

        if notify:
            self._strategy.on_order_event(user_order)  # notify about FILL

    ####################################################################################################
    # Private Methods for checking errors
    ####################################################################################################

    def _check_new_order_errors(self, request: NewOrder, response: inv.PostOrderResponse):
        assert request.idempotency_key in self._orders.pending_orders, f'Sanity check'
        assert request.instrument.figi == response.figi, 'Sanity check'
        if response.execution_report_status not in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW,
                                                    inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL,
                                                    inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL]:
            raise RuntimeError(f'Wrong response status: {response.execution_report_status}; message: {response.message}')
        assert request.quantity == response.lots_requested, 'Sanity check'
        assert request.order_type == OrderType.LIMIT or request.quantity == response.lots_executed, 'Market order should be always executed'
        assert request.order_type == OrderType.LIMIT or response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL, 'Market order should be always executed'
        assert (request.order_type == OrderType.MARKET or
                response.execution_report_status not in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL,
                                                         inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL] or
                float_to_quotation(request.price) == response.executed_order_price), 'Limit order fill price should be the same as we requested'
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            assert response.lots_executed == request.quantity, 'Sanity check'
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL:
            assert response.lots_executed < request.quantity, 'Sanity check'
        # TODO: remove commission check due to change in commissions
        assert quotation_to_float(response.initial_commission) == 0 and quotation_to_float(response.executed_commission) == 0, 'Commission check'

    def _check_get_order_errors(self, order: inv.OrderState) -> bool:
        """
        Return False => do not need to process this update
        """
        if order.order_id not in self._orders.open_orders and order.order_id not in self._orders.pending_orders and order.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW:
            self._logger.error('Did not get PostOrder response yet')
            return False
        assert order.order_id in self._orders.open_orders or order.order_id in self._orders.pending_orders, 'Sanity check'  # TODO: remove?
        assert order.order_type == inv.OrderType.ORDER_TYPE_LIMIT, 'Sanity check'  # TODO: remove?
        user_order = self._orders.open_orders[order.order_id] if order.order_id in self._orders.open_orders else self._orders.pending_orders[order.order_id]
        assert order.lots_requested == user_order.initial_quantity, 'Sanity check'
        assert order.execution_report_status in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW,
                                                 inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL,
                                                 inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL], 'Sanity check'
        # TODO: remove commission check due to change in commissions
        assert quotation_to_float(order.initial_commission) == 0 and quotation_to_float(order.executed_commission) == 0 and quotation_to_float(order.service_commission) == 0, 'Commission check'
        return True
