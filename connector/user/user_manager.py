import logging
import typing as tp
import time
import asyncio
import uuid
from dataclasses import dataclass
from collections import deque
from enum import Enum

import tinkoff.invest as inv
from tinkoff.invest.async_services import AsyncServices
from connector.info.info_manager import InfoManager, InstrumentInfo
from connector.common.log import Logging
from connector.common.quotation import quotation_to_float, float_to_quotation

if tp.TYPE_CHECKING:
    from connector.runner import Runner
    from connector.strategy import Strategy


####################################################################################################
# Strategy actions
####################################################################################################

class OrderDirection(Enum):
    BUY = 1
    SELL = -1


class OrderType(Enum):
    LIMIT = 0
    MARKET = 1


@dataclass
class NewOrder:
    instrument: InstrumentInfo
    order_type: OrderType
    direction: OrderDirection
    quantity: int  # number of lots
    price: float | None  # per instrument (not per lot), missing for market orders
    idempotency_key: str | None = None  # optional, 36-length, can be generated by uuid.uuid4()


@dataclass
class CancelOrder:
    order_id: str


@dataclass
class ModifyOrder:
    order_id: str
    new_quantity: int  # number of lots
    new_price: float  # per instrument (not per lot)


Action = NewOrder | CancelOrder | ModifyOrder


####################################################################################################
# Positions and Open orders
####################################################################################################

@dataclass
class Position:
    balance: int  # available security quantity
    blocked: int  # blocked security quantity for limit orders


@dataclass
class Positions:
    money: float  # available money in rubles
    blocked: float  # blocked money for limit orders
    securities: dict[str, Position]  # security position by figi


class OrderStatus(Enum):
    PENDING_OPEN = 0  # initial status
    PENDING_CANCEL = 1
    PENDING_MODIFY = 2
    OPEN = 3
    PART_FILL = 4
    FILL = 5  # final status
    CANCEL = 6  # final status


@dataclass
class UserOrder:
    # constant fields
    instrument: InstrumentInfo
    order_type: OrderType
    direction: OrderDirection
    initial_quantity: int  # number of lots

    # order ids
    order_id: str | None  # exchange_id
    idempotency_key: str  # key to repeat order request, constant

    # changing fields
    filled_quantity: int  # number of lots
    price: float | None  # per instrument (not per lot), missing for market orders
    status: OrderStatus


@dataclass
class Orders:
    # orders by id
    pending_orders: dict[str, UserOrder]  # pending Orders by idempotency_key
    open_orders: dict[str, UserOrder]  # open User Orders by order_id
    finished_orders: dict[str, UserOrder]  # finished User Orders by order_id


####################################################################################################
# Rate limits manager for one method
####################################################################################################

class RateLimiter:
    SECONDS_IN_MINUTE = 61  # more than 60 for precision errors

    def __init__(self, logger: logging.Logger, method_name: str, limit_per_minute: int):
        self._logger = logger
        self._queue: deque[float] = deque()  # queue with request times
        self._limit_per_minute = limit_per_minute
        self._method_name = method_name

    async def wait_until_available(self) -> None:
        """
        Wait until the request is available
        """
        while True:
            self._remove_irrelevant_requests()
            if len(self._queue) < self._limit_per_minute:
                # queue is not full, just add new request
                self._queue.append(time.time())
                return
            wait_time = self.SECONDS_IN_MINUTE - (time.time() - self._queue[0])
            self._logger.warning(f'Rate limit exceeded for {self._method_name}: wait {wait_time}s')
            await asyncio.sleep(wait_time)

    def get_optimal_time_between_requests(self) -> float:
        """
        Returns optimal time to wait between two requests in seconds
        """
        self._remove_irrelevant_requests()
        if not self._queue:
            return self.SECONDS_IN_MINUTE / self._limit_per_minute
        remaining_time = self.SECONDS_IN_MINUTE - (time.time() - self._queue[0])
        remaining_requests = self._limit_per_minute - len(self._queue)
        optimal_wait_time = remaining_time / remaining_requests
        self._logger.debug(f'{self._method_name}: {remaining_time=}, {remaining_requests=}, {optimal_wait_time=}')
        return optimal_wait_time

    def _remove_irrelevant_requests(self) -> None:
        """
        Remove requests from queue, that do not affect current request
        """
        now = time.time()
        while self._queue and now - self._queue[0] > self.SECONDS_IN_MINUTE:
            self._queue.popleft()


class UserManager:
    # gRPC rate limits per minute (https://tinkoff.github.io/investAPI/limits/):
    RATE_LIMITS = {
        'get_orders': 200,
        'post_order': 300,
        'cancel_order': 100
    }

    N_ORDER_CONSUMERS = 10  # number of order placers

    def __init__(self):
        self._logger = Logging.get_logger('UserManager')

        # account info
        self._account_id: str | None = None
        self._account: inv.Account | None = None

        # helpers
        self._strategy: tp.Union['Strategy', None] = None
        self._rn: tp.Union['Runner', None] = None
        self._im: InfoManager | None = None
        self._services: AsyncServices | None = None

        # strategy positions and orders
        self._positions: Positions | None = None
        self._orders: Orders = Orders(pending_orders={}, open_orders={}, finished_orders={})

        # rate limiters
        self._rate_limiters: dict[str, RateLimiter] = {
            method_name: RateLimiter(self._logger, method_name, limit) for method_name, limit in self.RATE_LIMITS.items()
        }

        # queue for strategy actions
        self._order_queue: asyncio.Queue[Action] = asyncio.Queue()

    ####################################################################################################
    # Methods for Strategy
    ####################################################################################################

    def new_order(self, order: NewOrder):
        self._logger.info(f'put NewOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    def cancel_order(self, order: CancelOrder):
        self._logger.info(f'put CancelOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    def modify_order(self, order: ModifyOrder):
        self._logger.info(f'put ModifyOrder in the queue: {order}')
        self._order_queue.put_nowait(order)  # put action in the queue to be processed later

    ####################################################################################################
    # Methods for Runner
    ####################################################################################################

    def set_services(self, services: AsyncServices):
        """
        Only for use in Runner (not in strategy)
        """
        self._services = services

    def set_strategy(self, strategy: 'Strategy') -> None:
        """
        Only for use in Runner (not in strategy)
        """
        self._strategy = strategy

    def set_helpers(self, rn: 'Runner', im: InfoManager) -> None:
        """
        Only for use in Runner (not in strategy)
        """
        self._rn = rn
        self._im = im
        self._account_id = self._rn.get_account_id()

    async def run(self):
        """
        UserManager loop of events
        """
        # get trading account
        await self._get_account()
        # get initial positions
        await self._get_positions()
        # notify Runner that UserManager is ready
        self._rn.on_user_manager_ready()

        # order consumers loop
        consumers = [asyncio.create_task(self._order_consumer()) for _ in range(self.N_ORDER_CONSUMERS)]
        await asyncio.gather(*consumers, self._monitor_orders())

    ####################################################################################################
    # Private Methods for initial Positions retrieval
    ####################################################################################################

    async def _get_positions(self) -> None:
        positions = await self._services.operations.get_positions(account_id=self._account_id)
        self._logger.info(f'tinkoff positions={positions}')

        # check money positions
        money: float | None = None
        for quotation in positions.money:
            assert quotation.currency == 'rub', 'Only ruble money value is supported'
            assert money is None, 'Multiple money values are found'
            money = quotation_to_float(quotation)
        assert len(positions.blocked) == 0, 'Remove all old buy orders before starting strategy'

        # check segments positions
        assert len(positions.futures) == 0 and len(positions.options) == 0, 'Close all futures and options positions'

        # check security positions
        security_positions_by_figi: dict[str, Position] = {}
        for security in positions.securities:
            assert self._im.has_instrument_by_figi(security.figi), 'Unknown security position found'
            assert security.blocked == 0, 'Remove all old sell orders before starting strategy'
            assert not security.exchange_blocked, 'Instrument is blocked on exchange'
            assert security.balance > 0, 'Sanity check'
            assert security.instrument_type == self._im.get_instrument_by_figi(security.figi).instrument_type, f'Sanity check'
            security_positions_by_figi[security.figi] = Position(balance=security.balance, blocked=security.blocked)

        # fill positions
        self._positions = Positions(money=money, blocked=0.0, securities=security_positions_by_figi)
        self._logger.info(f'parsed positions={self._positions}')

    async def _get_account(self) -> None:
        """
        Find an account to trade on
        Fill self._account field
        """
        accounts = (await self._services.users.get_accounts()).accounts
        # log all accounts
        self._logger.info(f'number of accounts: {len(accounts)}')
        for account in accounts:
            self._logger.info(f'found account: {account}')
        assert self._account_id is not None, 'Account was not specified'
        # get trading account
        try:
            trading_account = next(filter(lambda acc: acc.id == self._account_id, accounts))
        except StopIteration:
            self._logger.error(f'account with id={self._account_id} was not found')
            raise
        # accessibility checks
        assert trading_account.status == inv.AccountStatus.ACCOUNT_STATUS_OPEN, f'Account {trading_account} must be opened'
        assert trading_account.access_level == inv.AccessLevel.ACCOUNT_ACCESS_LEVEL_FULL_ACCESS, f'Must have full access to {trading_account}'
        # fill field
        self._account = trading_account

        # log user rate limits
        limits = await self._services.users.get_user_tariff()
        self._logger.info(f'User Limits: {limits}')

        # log user tariff
        tariff = await self._services.users.get_info()
        self._logger.info(f'tariff="{tariff.tariff}"; is_premium={tariff.prem_status}; is_qual={tariff.qual_status}; qualified_for_work_with={tariff.qualified_for_work_with}')

    ####################################################################################################
    # Private Method for monitoring open orders
    ####################################################################################################

    async def _monitor_orders(self):
        rate_limiter = self._rate_limiters['get_orders']
        while True:
            wait_time = rate_limiter.get_optimal_time_between_requests()
            await asyncio.sleep(wait_time)
            await rate_limiter.wait_until_available()
            response = await self._services.orders.get_orders(account_id=self._account_id)
            self._logger.debug(f'Got GetOrders response: {len(response.orders)} orders: {response}')
            for order in response.orders:
                self._process_get_order(order)
            order_ids = {order.order_id for order in response.orders}
            for order_id, user_order in self._orders.open_orders.items():
                await rate_limiter.wait_until_available()
                response = await self._services.orders.get_order_state(account_id=self._account_id, order_id=order_id)
                assert response.order_id == order_id, 'Sanity check'
                self._process_get_order(response)

    ####################################################################################################
    # Private Method for handling rate limits
    ####################################################################################################

    async def _wait_until_available(self, method: str) -> None:
        """
        Wait until the request is available
        """
        await self._rate_limiters[method].wait_until_available()

    ####################################################################################################
    # Private Methods for processing strategy actions
    ####################################################################################################

    async def _order_consumer(self):
        """
        Consume and process orders from the order_queue
        """
        while True:
            order = await self._order_queue.get()
            self._logger.info(f'process from queue: {order}')
            await self._process_action(order)

    async def _process_action(self, order: Action) -> None:
        """
        Process strategy order
        """
        if isinstance(order, NewOrder):
            await self._process_new_order(order)
        elif isinstance(order, CancelOrder):
            await self._process_cancel_order(order)
        elif isinstance(order, ModifyOrder):
            await self._process_modify_order(order)
        else:
            assert False, 'Unreachable'

    async def _process_new_order(self, order: NewOrder) -> None:
        """
        NewOrder
        """
        # construct order
        assert order.order_type == OrderType.MARKET or order.price is not None, 'Limit order must have price'
        idempotency_key = str(uuid.uuid4())
        user_order = UserOrder(
            instrument=order.instrument,
            order_type=order.order_type,
            direction=order.direction,
            initial_quantity=order.quantity,
            order_id=None,
            idempotency_key=idempotency_key,
            filled_quantity=0,
            price=order.price,
            status=OrderStatus.PENDING_OPEN
        )
        assert idempotency_key not in self._orders.pending_orders, 'Sanity check'
        self._orders.pending_orders[idempotency_key] = user_order

        # send order
        price_quotation = float_to_quotation(order.price) if order.order_type == OrderType.LIMIT else None
        await self._wait_until_available('post_order')
        response = await self._services.orders.post_order(
            figi=order.instrument.figi,
            quantity=order.quantity,
            price=price_quotation,
            direction=inv.OrderDirection.ORDER_DIRECTION_BUY if order.direction == OrderDirection.BUY else inv.OrderDirection.ORDER_DIRECTION_SELL,
            account_id=self._account_id,
            order_type=inv.OrderType.ORDER_TYPE_LIMIT if order.order_type == OrderType.LIMIT else inv.OrderType.ORDER_TYPE_MARKET,
            order_id=idempotency_key  # inconsistent tinkoff naming, actually it is idempotency_key
        )

        # check response for errors
        self._logger.info(f'Got PostOrder response: {response}')
        assert order.instrument.figi == response.figi, 'Sanity check'
        if response.execution_report_status not in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW,
                                                    inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL,
                                                    inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL]:
            raise RuntimeError(f'Wrong response status: {response.execution_report_status}; message: {response.message}')
        assert order.quantity == response.lots_requested, 'Sanity check'

        assert order.order_type == OrderType.LIMIT or order.quantity == response.lots_executed, 'Market order should be always executed'
        assert (order.order_type == OrderType.MARKET or
                response.execution_report_status not in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL,
                                                         inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL] or
                price_quotation == response.executed_order_price), 'Limit order fill price should be the same as we requested'
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            assert response.lots_executed == order.quantity, 'Sanity check'
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL:
            assert response.lots_executed < order.quantity, 'Sanity check'
        # TODO: remove commission check due to change in commissions
        assert quotation_to_float(response.initial_commission) == 0 and quotation_to_float(response.executed_commission) == 0, 'Commission check'

        # remove order from pending_orders
        self._orders.pending_orders.pop(idempotency_key)
        # add order to open_orders or finished_orders
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            self._orders.finished_orders[response.order_id] = user_order
        else:
            self._orders.open_orders[response.order_id] = user_order

        # update pending_order_id (idempotency_key) -> order_id
        user_order.order_id = response.order_id
        # update status
        user_order.status = self._tinkoff_order_status_to_local(response.execution_report_status)
        # update filled quantity
        user_order.filled_quantity = response.lots_executed
        # notify strategy
        self._strategy.on_order_event(user_order)

    async def _process_cancel_order(self, order: CancelOrder) -> None:
        """
        CancelOrder
        """
        assert order.order_id in self._orders.open_orders, 'Sanity check'
        user_order = self._orders.open_orders[order.order_id]
        user_order.status = OrderStatus.PENDING_CANCEL  # update order status
        # open order -> pending order
        self._orders.open_orders.pop(order.order_id)
        self._orders.pending_orders[order.order_id] = user_order
        await self._wait_until_available('cancel_order')
        if order.order_id not in self._orders.open_orders:
            self._logger.error(f'Order {order.order_id} was finished before cancel')
            return
        response = await self._services.orders.cancel_order()
        # log response
        self._logger.info(f'Got CancelOrder response: {response}')
        # remove order from pending_orders
        self._orders.open_orders.pop(order.order_id)
        # add order to finished_orders
        self._orders.finished_orders[order.order_id] = user_order
        # update status
        user_order.status = OrderStatus.CANCEL
        # notify strategy
        self._strategy.on_order_event(user_order)

    async def _process_modify_order(self, order: ModifyOrder) -> None:
        """
        ModifyOrder
        """
        assert order.order_id in self._orders.open_orders, 'Sanity check'
        user_order = self._orders.open_orders[order.order_id]
        user_order.status = OrderStatus.PENDING_MODIFY
        # open order -> pending order
        self._orders.open_orders.pop(order.order_id)
        self._orders.pending_orders[order.order_id] = user_order
        # TODO: check rate limits
        await self._wait_until_available('cancel_order')
        await self._wait_until_available('post_order')
        idempotency_key = str(uuid.uuid4())
        request = inv.ReplaceOrderRequest()  # construct request due to python-sdk library problems
        request.account_id = self._account_id
        request.order_id = order.order_id
        request.idempotency_key = idempotency_key
        request.quantity = order.new_quantity
        request.price = float_to_quotation(order.new_price)
        request.price_type = inv.PriceType.PRICE_TYPE_UNSPECIFIED
        response = await self._services.orders.replace_order(request)

        # remove order from pending_orders
        self._orders.pending_orders.pop(idempotency_key)
        # add order to open_orders or finished_orders
        if response.execution_report_status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            self._orders.finished_orders[response.order_id] = user_order
        else:
            self._orders.open_orders[response.order_id] = user_order
        # update order_id
        user_order.order_id = response.order_id
        # update status
        user_order.status = self._tinkoff_order_status_to_local(response.execution_report_status)
        # update filled quantity
        user_order.filled_quantity = response.lots_executed
        # notify strategy
        self._strategy.on_order_event(user_order)

    def _process_get_order(self, order: inv.OrderState) -> None:
        # checks
        assert order.order_id in self._orders.open_orders, 'Sanity check'  # TODO: remove?
        assert order.order_type == inv.OrderType.ORDER_TYPE_LIMIT, 'Sanity check'  # TODO: remove?
        user_order = self._orders.open_orders[order.order_id]
        price_quotation = inv.Quotation(units=order.initial_order_price.units, nano=order.initial_order_price.nano)
        assert price_quotation == float_to_quotation(user_order.price), 'Sanity check'
        assert order.lots_requested == user_order.initial_quantity, 'Sanity check'
        assert order.execution_report_status in [inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW,
                                                 inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL,
                                                 inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL], 'Sanity check'
        # TODO: remove commission check due to change in commissions
        assert quotation_to_float(order.initial_commission) == 0 and quotation_to_float(order.executed_commission) == 0 and quotation_to_float(order.service_commission) == 0, 'Commission check'

        new_status = self._tinkoff_order_status_to_local(order.execution_report_status)
        if user_order.status != new_status:
            self._logger.warning(f'Order {order.order_id} changed status: {user_order.status} -> {new_status}')
            user_order.status = new_status
        if user_order.filled_quantity < order.lots_executed:
            self._logger.info(f'Order {order.order_id} changed filled quantity: {user_order.filled_quantity}/{user_order.initial_quantity} -> {order.lots_executed}/{order.lots_requested}')
            user_order.filled_quantity = order.lots_executed
            if user_order.status != inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
                self._strategy.on_order_event(user_order)  # notify about PARTIAL_FILL
        if user_order.status == inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
            user_order.status = OrderStatus.FILL
            assert user_order.filled_quantity == user_order.initial_quantity, 'Sanity check'
            self._logger.info(f'Order {order.order_id} is filled: {user_order.filled_quantity}/{user_order.initial_quantity}')
            # remove from open orders
            self._orders.open_orders.pop(order.order_id)
            # add to finished orders
            self._orders.finished_orders[order.order_id] = user_order
            self._strategy.on_order_event(user_order)  # notify about FILL

    @staticmethod
    def _tinkoff_order_status_to_local(status: inv.OrderExecutionReportStatus):
        match status:
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_NEW:
                return OrderStatus.OPEN
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_FILL:
                return OrderStatus.FILL
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_PARTIALLYFILL:
                return OrderStatus.PART_FILL
            case inv.OrderExecutionReportStatus.EXECUTION_REPORT_STATUS_CANCELLED:
                return OrderStatus.CANCEL
            case _:
                assert False, 'Unreachable'
